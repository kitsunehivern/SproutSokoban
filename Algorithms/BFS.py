import time
import psutil
from collections import deque
from enum import Enum


class Move(Enum):
    UP = (-1, 0)
    DOWN = (1, 0)
    LEFT = (0, -1)
    RIGHT = (0, 1)


class Direction(Enum):
    UP = "u"
    DOWN = "d"
    LEFT = "l"
    RIGHT = "r"


class Cell(Enum):
    WALL = "#"
    EMPTY = " "
    STONE = "$"
    PLAYER = "@"
    SWITCH = "."
    STONE_SWITCH = "*"
    PLAYER_SWITCH = "+"


moveToDirection = {
    Move.UP: Direction.UP,
    Move.DOWN: Direction.DOWN,
    Move.LEFT: Direction.LEFT,
    Move.RIGHT: Direction.RIGHT,
}


def getStartPos(grid):
    """
    Get the starting position of the grid.

    Parameters:
        grid (list[list[char]]): A 2D list representing the grid to search.

    Returns:
        playerStart (tuple[int, int]): A tuple representing the starting position.
        stonesStart (tuple[tuple[int, int]]): A list of tuples representing the starting positions of the stones.
        switches (tuple[tuple[int, int]]): A list of tuples representing the positions of the switches.
    """
    playerStart = None
    stonesStart = []
    switches = []
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] in [Cell.PLAYER.value, Cell.PLAYER_SWITCH.value]:
                playerStart = (i, j)
            if grid[i][j] in [Cell.STONE.value, Cell.STONE_SWITCH.value]:
                stonesStart.append((i, j))
            if grid[i][j] in [
                Cell.SWITCH.value,
                Cell.PLAYER_SWITCH.value,
                Cell.STONE_SWITCH.value,
            ]:
                switches.append((i, j))
    return playerStart, tuple(stonesStart), tuple(switches)


def isGoal(stones, switches):
    """
    Check if all stones are on the switches.

    Parameters:
        stones (list[tuple[int, int]]): A list of tuples representing the positions of the stones.
        switches (list[tuple[int, int]]): A list of tuples representing the positions of the switches.

    Returns:
        bool: True if the state is a goal state, False otherwise.
    """
    return all(stone in switches for stone in stones)


def isInGridAndNotWall(grid, pos):
    """
    Check if the position is in the grid and not a wall.

    Parameters:
        grid (list[list[char]]): A 2D list representing the grid to search.
        pos (tuple[int, int]): A tuple representing the position to check.

    Returns:
        bool: True if the position is in the grid and not a wall, False otherwise.
    """
    return (
        0 <= pos[0] < len(grid)
        and 0 <= pos[1] < len(grid[0])
        and grid[pos[0]][pos[1]] != Cell.WALL.value
    )


def transition(weights, grid, state, move):
    """
    Perform a transition on the given state.

    Parameters:
        weights (list[int]): A list of stone weights.
        grid (list[list[char]]): A 2D list representing the grid to search.
        state (tuple[tuple[int, int]]): A tuple representing the current state.
        move (Move): A Move enum representing the move to make.

    Returns:
        newState (tuple[tuple[int, int]]): A tuple representing the new state.
        cost (int): The cost of the move.
    """
    player = state[0]
    stones = state[1]

    newPlayer = (player[0] + move.value[0], player[1] + move.value[1])
    if not isInGridAndNotWall(grid, newPlayer):
        return None

    cost = None
    newStones = []
    for index, stone in enumerate(stones):
        newStone = stone
        if stone == newPlayer:
            cost = weights[index]
            newStone = (stone[0] + move.value[0], stone[1] + move.value[1])
            if not (isInGridAndNotWall(grid, newStone) and newStone not in stones):
                return None
        newStones.append(newStone)

    return (newPlayer, tuple(newStones)), cost


def backtrack(previousStateMap, goal):
    path = ""
    weight = 0
    while previousStateMap[goal] != -1:
        prev, move, cost = previousStateMap[goal]
        char = moveToDirection[move].value
        if cost is not None:
            char = char.upper()
            weight += cost
        path = char + path
        goal = prev
    return path, weight


def getOutput(weights, grid):
    """
    Perform Breadth-First Search (BFS) on the given grid.

    Parameters:
        weights (list[int]): A list of integer weights.
        grid (list[list[char]]): A 2D list representing the grid to search.

    Returns:
        path (str): A string representing the path from the start to the goal.
        steps (int): The number of steps taken to reach the goal.
        weight (int): The total weight Ares has to push.
        node (int): The number of expanded nodes generated by the algorithm.
        time (int): The time taken to run the algorithm in milliseconds.
        memory (int): The memory used by the algorithm in megabytes.
    """
    playerStart, stonesStart, switches = getStartPos(grid)

    initialState = (playerStart, stonesStart)

    queue = deque([initialState])
    previousStateMap = {}
    previousStateMap[initialState] = -1

    # tracemalloc.start()
    start_time = time.time()
    # start_memory = tracemalloc.get_traced_memory()[0]
    process = psutil.Process()
    start_memory = process.memory_info().rss

    ans = None

    while queue:
        current = queue.popleft()

        if isGoal(current[1], switches):
            path, weight = backtrack(previousStateMap, current)
            ans = {
                "path": path,
                "steps": len(path),
                "weight": weight,
                "node": len(previousStateMap),
                "time": (time.time() - start_time) * 1000,
                "memory": max((process.memory_info().rss - start_memory) / 2**20, 0.0),
                # "memory": (tracemalloc.get_traced_memory()[1] - start_memory) / 2**20,
            }
            # ans = (path, len(path), weight, len(previousStateMap), (time.time() - start_time) * 1000, (tracemalloc.get_traced_memory()[1]-start_memory) / 2**20)
            break

        for move in Move:
            result = transition(weights, grid, current, move)
            if result is None:
                continue
            newState, cost = result
            if newState not in previousStateMap:
                queue.append(newState)
                previousStateMap[newState] = (current, move, cost)

    if ans is None:
        return None

    return (
        ans["steps"],
        ans["weight"],
        ans["node"],
        ans["time"],
        ans["memory"],
        ans["path"],
    )
